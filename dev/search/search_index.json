{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Usage","text":""},{"location":"#cookiecutter-pypackage","title":"Cookiecutter PyPackage","text":"<p>Cookiecutter template for a Python package</p> <p>Documentation: https://bdpedigo.github.io/cookiecutter-pypackage</p>"},{"location":"#features","title":"Features","text":"<p>This tool will create Python project with the following features:</p> <ul> <li>Poetry: Manage dependency, build and release</li> <li>Mkdocs: Writing your docs in markdown style</li> <li>Testing with Pytest (unittest is still supported out of the box)</li> <li>Tox: Test your code against environment matrix, lint and artifact check</li> <li>Ruff for formatting, linting, and import sorting</li> <li>Same functionality as Black, Isort and Flake8 bundled together</li> <li>Check static type with Mypy (optional)</li> <li>Pre-commit hooks: Formatting/linting anytime when commit your code</li> <li>Mkdocstrings: Auto API doc generation</li> <li>Host your documentation from GitHub Pages with zero-config</li> <li>Continuous Integration/Deployment by GitHub actions, includes:</li> <li>publish dev build to TestPyPI and dev docs automatically when tests pass for each commit to <code>main</code></li> <li>bump version, publish release to PyPI, and publish versioned documentation using a manual GitHub action</li> <li>daily test runs to catch dependency update and CI failure</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>To start, you will need [GitHub], [PyPI], and [TestPyPI] accounts. If you don't have one, please follow the links to apply one before you get started on this tutorial.</p> <p>If you are new to Git and GitHub, you should probably spend a few minutes on some tutorials at the top of the page at [GitHub Help].</p>"},{"location":"#cookiecutter-installation","title":"Cookiecutter installation","text":"<p>Install Cookiecutter if you haven't installed it yet (this requires Cookiecutter 1.4.0 or higher). Currently, since Cookiecutter is itself a python package with its own dependencies, it is recommended to use <code>pipx</code> to do so:</p> <pre><code>pipx install cookiecutter\n</code></pre> <p>This should enable you to run <code>cookiecutter</code> from the command line. To generate a Python package project using this template, run the following command and follow the prompts:</p> <pre><code>cookiecutter https://github.com/bdpedigo/cookiecutter-pypackage.git\n</code></pre>"},{"location":"#generate-your-package","title":"Generate your package","text":"<p>Now it's time to generate your Python package.</p> <p>Run the following command and feed with answers, If you don\u2019t know what to enter, stick with the defaults:</p> <pre><code>cookiecutter https://github.com/bdpedigo/cookiecutter-pypackage.git\n</code></pre> <p>Finally, a new folder will be created under current folder, the name is the answer you provided to <code>project_slug</code>.</p> <p>Go to this generated folder, the project layout should look like:</p> <pre><code>.\n\u251c\u2500\u2500 .bumpversion.cfg\n\u251c\u2500\u2500 .editorconfig\n\u251c\u2500\u2500 .github\n\u2502   \u251c\u2500\u2500 ISSUE_TEMPLATE.md\n\u2502   \u2514\u2500\u2500 workflows\n\u2502       \u251c\u2500\u2500 dev.yml\n\u2502       \u251c\u2500\u2500 preview.yml\n\u2502       \u2514\u2500\u2500 release.yml\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .pre-commit-config.yaml\n\u251c\u2500\u2500 CHANGELOG.md\n\u251c\u2500\u2500 CONTRIBUTING.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 api.md\n\u2502   \u251c\u2500\u2500 changelog.md\n\u2502   \u251c\u2500\u2500 contributing.md\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 installation.md\n\u2502   \u2514\u2500\u2500 usage.md\n\u251c\u2500\u2500 makefile\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 my_package\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 cli.py\n\u2502   \u2514\u2500\u2500 my_package.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 setup.cfg\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test_my_package.py\n</code></pre> <p>Here the project_slug is <code>my-package</code>, when you generate yours, it could be other name.</p> <p>Also be noticed that there's <code>pyproject.toml</code> in this folder. This is the main configuration file of our project.</p>"},{"location":"#create-a-github-repo","title":"Create a GitHub repo","text":"<p>Create a new GitHub repo. Do not initialize with a README or any other files.</p> <p>Follow the instructions there for uploading your existing repo from the command line. It should look something like this (where { owner name } is your GitHub username and { repo name } is the name of your repo):</p> <pre><code>git init\ngit add .\ngit commit -m \"initial commit\"\ngit branch -M main\ngit remote add origin https://github.com/{ owner name }/{ repo name }.git\ngit push -u origin main\n</code></pre>"},{"location":"#install-poetry","title":"Install Poetry","text":"<p>Next, install Poetry if you haven't already. I recommend installing according to their most recent instructions. As of this writing, the recommended way to install Poetry is with [pipx](</p> <pre><code>pipx install poetry\n</code></pre> <p>In addition, Poetry provides a custom installer that will install poetry isolated from the rest of your system by vendorizing its dependencies. This is the recommended way of installing poetry.</p>"},{"location":"#install-developer-requirements","title":"Install developer requirements","text":"<p>You should still be in the folder named <code>project_slug</code>, which contains the <code>pyproject.toml</code> file.</p> <p>It is a good idea to make a new virtual environment, although Poetry will also do this automatically for you in the next step. If you would like to do this manually, you can use the following command:</p> <pre><code>poetry env use &lt;path to Python interpreter&gt;\n</code></pre> <p>For instance, to use the Python 3.11 interpreter linked to the alias <code>python3.11</code>, you would run:</p> <pre><code>poetry env use python3.11\n</code></pre> <p>By default, this will create a virtual environment in the <code>.venv</code> folder in your project directory. To activate this virtual environment, run:</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>or</p> <pre><code>poetry shell\n</code></pre> <p>With the environment active, install the new project's local development requirements with <code>poetry install</code>:</p> <pre><code>poetry install --with dev\n</code></pre> <p>Poetry will create its own virtualenv isolated from your system and install the dependencies in it. We installed extra dependency needed by developers with the <code>--with dev</code> option, such as documentation build tools, linting, formatting and test tools etc.</p>"},{"location":"#run-tests","title":"Run tests","text":"<p>We also launch a test here by running <code>poetry run tox</code>. This will run <code>tox</code> within created virtual environment, give you a test report and lint report. You should see no errors except some lint warnings.</p> <pre><code>poetry run tox\n</code></pre> <p>If you found errors like the following during tox run:</p> <pre><code>ERROR: InterpreterNotFound: python3.9\n</code></pre> <p>don't be panic, this is just because python3.x is not found on your machine. If you decide to support that version of Python in your package, please install it on your machine. Otherwise, remove it from tox.ini and pyproject.toml (search python3.x then remove it).</p>"},{"location":"#change-github-settings","title":"Change GitHub settings","text":"<p>Maybe not needed by default</p> <p>On GitHub, go to your new repo and click on the \"Settings\" tab. Then click on \"Actions\" in the left sidebar. Under \"Workflow permissions\", check the box for \"Read and write permissions\".</p>"},{"location":"#initialize-documentation","title":"Initialize documentation","text":"<pre><code>mike deploy --push --update-aliases dev\n</code></pre> <p>This should be all that's required to set up GitHub Pages for your documentation. You can see if this worked by going to the \"Settings\" tab of your repo on GitHub and scrolling down to the \"GitHub Pages\" section. If everything worked, you should see a message that says \"Your site is published at...\" with a link to your documentation. It may take a few minutes for the link to work.</p> <p>At this point, all that has been build and served is the \"dev\" version of your documentation, so following the GitHub Pages link will not work. Instead, append <code>/dev</code> to the end of the URL to see the documentation. This version of the site will update automatically with each commit to <code>main</code>, even if you haven't made a release. Because this is unstable, it is not the default landing site for visitors to your docs. To view the stable version, we'll first need to make a release.</p>"},{"location":"#set-up-publishing","title":"Set up publishing","text":"<ul> <li>Go to PyPI</li> <li>Log in</li> <li>In your account, go to Publishing</li> <li>You may need to set up 2FA at this point</li> <li>Hit \"Add a new pending publisher\"</li> <li>Under GitHub, fill out the details of your package</li> <li>Use <code>release.yml</code> under \"Workflow name\"</li> <li>If setting up TestPyPI, do all of the above again on TestPyPI, but use <code>test-release.yml</code> as the workflow.</li> <li>If you make a commit on the repo, TestPyPI should automatically cut a pre-release version.</li> </ul>"},{"location":"#create-a-release","title":"Create a release","text":"<p>You can cut a release using the pre-made GitHub action. Go to the repo on GitHub, hit the \"Actions\" tab, and click \"publish release.\" You should see a button on the top right that says \"Run workflow.\" Uncheck \"dry run\" and run the workflow for a \"patch\" bump just to test things out.</p>"},{"location":"console_script_setup/","title":"Console script","text":""},{"location":"console_script_setup/#console-script-setup","title":"Console Script Setup","text":"<p>Optionally, your package can include a console script using Click.</p>"},{"location":"console_script_setup/#how-it-works","title":"How It Works","text":"<p>If the <code>command_line_interface</code> option is set to <code>click</code> during setup, cookiecutter  will add a file <code>cli.py</code> in the <code>pkg_name</code> subdirectory. An entry point is added to <code>pyproject.toml</code> that points to the main function in cli.py.</p>"},{"location":"console_script_setup/#usage","title":"Usage","text":"<p>To use the console script in development:</p> <pre><code>poetry install\n</code></pre> <p>Then execute: <pre><code>$project_slug --help\n</code></pre></p> <p>it will show your package name, project short description and exit.</p>"},{"location":"console_script_setup/#more-details","title":"More Details","text":"<p>You can read more about Python Click at Click.</p>"},{"location":"faq/","title":"FAQ","text":"Question Question Question Question Question"},{"location":"faq/#explain-these-github-workflows-yaml-files","title":"Explain these GitHub workflows yaml files?","text":"<ul> <li><code>dev.yml</code>: define dev workflow, run on every push and pull requests to master, basically run all the tests against multiple versions and platforms.</li> <li><code>preview.yml</code>: define stage &amp; preview workflow, run on every push to master, publish dev build to TestPyPI.</li> <li><code>release.yml</code>: define release &amp; publish workflow, run on every tag push, create GitHub release, publish docs to GitHub Pages and built package to PyPI.</li> </ul>"},{"location":"faq/#why-not-travis-ci","title":"Why not travis CI?","text":"<p>Travis CI is a great service, however, github actions is super convenient, less configuration , better integration. Less configuration, less error prone.</p>"},{"location":"faq/#why-not-read-the-docs","title":"Why not read the docs?","text":"<p>Same reason as above. GitHub Pages is convenient than read the docs, it requires no further configuration, except access token. As to read the docs, you need to write v2 config file, plus several settings on web pages.</p>"},{"location":"faq/#why-mkdocs-over-sphinx","title":"Why mkdocs over sphinx?","text":"<p>reStructured Text and Sphinx is way to tedious, though powerful. With extension, you'll find almost all features are available in mkdocs, in a neat and productive way. Poetry and Markdown, are the two key factors driven me develop this template.</p>"},{"location":"faq/#what-are-the-configuration-items","title":"What are the configuration items?","text":"<p>Here is a list:</p> <pre><code>## Templated Values\n\nThe following appear in various parts of your generated project.\n\nproject_name\nThe name of your new Python package project. This is used in\ndocumentation, so spaces and any characters are fine here.\n\nproject_slug\nThe name of your Python package for PyPI, also as the repository name of GitHub.\nTypically, it is the slugified version of project_name.\n\npkg_name\nThe namespace of your Python package. This should be Python import-friendly.\n\nproject_short_description\nA 1-sentence description of what your Python package does.\n\nfull_name\nYour full name.\n\nemail\nYour email address.\n\ngithub_username\nYour GitHub username.\n\nversion\nThe starting version number of the package.\n\nuse_mypy\nIf use mypy for static type check in pre-commit hooks and tox.\n\ninstall_precommit_hooks\nIf you choose yes, then cookiecutter will install pre-commit hooks for you.\n\ndocstrings_style\none of `google, numpy, pep257`. It's required by flake8-docstrings.\n\n## Options\n\nThe following package configuration options set up different features\nfor your project.\n\ncommand_line_interface\nWhether to create a console script using Python Click. Console script\nentry point will match the project_slug. Options: \\['click', \"No\ncommand-line interface\"\\]\n</code></pre> <p>except above settings, for CI/CD, you'll also need configure gitub repsitory secrets at page repo &gt; settings &gt; secrtes, and add the following secrets:</p> <ul> <li>PERSONAL_TOKEN (required for publishing document to git pages)</li> <li>TEST_PYPI_API_TOKEN (required for publishing dev release to testpypi)</li> <li>PYPI_API_TOKEN (required for publish )</li> </ul>"},{"location":"history/","title":"History","text":""},{"location":"history/#history","title":"History","text":""},{"location":"history/#v111","title":"v1.1.1","text":"<ul> <li>Centralize most of the tool configuration in the <code>setup.cfg</code> file</li> </ul>"},{"location":"history/#v110","title":"v1.1.0","text":"<ul> <li>Add <code>use_mypy</code> choice to make mypy optional</li> </ul>"},{"location":"history/#v10","title":"v1.0","text":"<p>first release with the following features:</p> <ul> <li>Poetry: Manage dependency, build and release</li> <li>Mkdocs: Writing your docs in markdown style</li> <li>Testing with Pytest (unittest is still supported out of the box)</li> <li>Code coverage report and endorsed by Codecov</li> <li>Tox: Test your code against environment matrix, lint and artifact check</li> <li>Format with Black and Isort</li> <li>Lint code with Flake8 and Flake8-docstrings</li> <li>Check static type with Mypy (optional)</li> <li>Pre-commit hooks: Formatting/linting anytime when commit your code</li> <li>Mkdocstrings: Auto API doc generation</li> <li>Command line interface using Click (optional)</li> <li>bump2version: Pre-configured version bumping with a single command</li> <li>Continuous Integration/Deployment by GitHub actions, includes:<ul> <li>publish dev build/official release to TestPyPI/PyPI automatically when CI success</li> <li>publish documents automatically when CI success</li> <li>extract changelog from CHANGELOG and integrate with release notes automatically</li> </ul> </li> <li>Host your documentation from GitHub Pages with zero-config</li> </ul>"},{"location":"pypi_release_checklist/","title":"Release checklist","text":""},{"location":"pypi_release_checklist/#pypi-release-checklist","title":"PyPI Release Checklist","text":""},{"location":"pypi_release_checklist/#before-your-first-release","title":"Before Your First Release","text":"<p>You better visit PyPI to make sure your package name is unused.</p>"},{"location":"pypi_release_checklist/#for-every-release","title":"For Every Release","text":"<ol> <li> <p>Make some pull requests, merge all changes from feature branch to master/main.</p> </li> <li> <p>Update CHANGELOG.md manually. Make sure it follows the Keep a Changelog standard.     Be noticed that GitHub workflow will read changelog and extract release notes automatically.</p> </li> <li> <p>Commit the changelog changes:</p> <pre><code>git add CHANGELOG.md\ngit commit -m \"Changelog for upcoming release 0.1.1.\"\n</code></pre> </li> <li> <p>Update version number and automatically create a commit, tag(can also be patch or major).</p> <pre><code>poetry run bump2version minor\n</code></pre> </li> <li> <p>Run the tests locally for insurance:</p> <pre><code>poetry run tox\n</code></pre> </li> <li> <p>Push these commits to master/main:</p> <pre><code>git push\n</code></pre> <p>Before proceeding to the next step, please check workflows triggered by this push have passed.</p> </li> <li> <p>Push the tags(created by bump2version) to master/main, creating the new release on both GitHub and PyPI:</p> <pre><code>git push --tags\n</code></pre> <p>Only tag name started with 'v'(lower case) will leverage GitHub release workflow.</p> </li> <li> <p>Check the PyPI listing page to make sure that the README, release     notes, and roadmap display properly. If tox test passed, this should be ok, since     we have already run twine check during tox test.</p> </li> </ol>"},{"location":"pypi_release_checklist/#about-this-checklist","title":"About This Checklist","text":"<p>This checklist is adapted from https://cookiecutter-pypackage.readthedocs.io/en/latest/pypi_release_checklist.html.</p> <p>It assumes that you are using all features of Cookiecutter PyPackage.</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#tutorial","title":"Tutorial","text":"<p>To start with, you will need GitHub, PyPI, and TestPyPI accounts. If you don't have one, please follow the links to apply one before you get started on this tutorial.</p> <p>If you are new to Git and GitHub, you should probably spend a few minutes on some tutorials at the top of the page at GitHub Help.</p>"},{"location":"tutorial/#step-1-install-cookiecutter","title":"Step 1: Install Cookiecutter","text":"<p>Install cookiecutter:</p> <pre><code>pip install cookiecutter\n</code></pre>"},{"location":"tutorial/#step-2-generate-your-package","title":"Step 2: Generate Your Package","text":"<p>Now it's time to generate your Python package.</p> <p>Run the following command and feed with answers, If you don\u2019t know what to enter, stick with the defaults:</p> <pre><code>cookiecutter https://github.com/bdpedigo/cookiecutter-pypackage.git\n</code></pre> <p>Finally, a new folder will be created under current folder, the name is the answer you provided to <code>project_slug</code>.</p> <p>Go to this generated folder, the project layout should look like:</p> <pre><code>.\n\u251c\u2500\u2500 .bumpversion.cfg\n\u251c\u2500\u2500 .editorconfig\n\u251c\u2500\u2500 .github\n\u2502   \u251c\u2500\u2500 ISSUE_TEMPLATE.md\n\u2502   \u2514\u2500\u2500 workflows\n\u2502       \u251c\u2500\u2500 dev.yml\n\u2502       \u251c\u2500\u2500 preview.yml\n\u2502       \u2514\u2500\u2500 release.yml\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .pre-commit-config.yaml\n\u251c\u2500\u2500 CHANGELOG.md\n\u251c\u2500\u2500 CONTRIBUTING.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 api.md\n\u2502   \u251c\u2500\u2500 changelog.md\n\u2502   \u251c\u2500\u2500 contributing.md\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 installation.md\n\u2502   \u2514\u2500\u2500 usage.md\n\u251c\u2500\u2500 makefile\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 my_package\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 cli.py\n\u2502   \u2514\u2500\u2500 my_package.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 setup.cfg\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test_my_package.py\n</code></pre> <p>Here the project_slug is <code>my-package</code>, when you generate yours, it could be other name.</p> <p>Also be noticed that there's <code>pyproject.toml</code> in this folder. This is the main configuration file of our project.</p>"},{"location":"tutorial/#step-3-install-poetry","title":"Step 3: Install Poetry","text":"<p>Next, install Poetry if you haven't already. I recommend installing according to their most recent instructions. As of this writing, the recommended way to install Poetry is with [pipx](</p> <pre><code>pipx install poetry\n</code></pre> <p>In addition, Poetry provides a custom installer that will install poetry isolated from the rest of your system by vendorizing its dependencies. This is the recommended way of installing poetry.</p>"},{"location":"tutorial/#step-4-install-dev-requirements","title":"Step 4: Install Dev Requirements","text":"<p>You should still be in the folder named as <code>project_slug</code>, which containing the <code>pyproject.toml</code> file.</p> <p>Install the new project's local development requirements with <code>poetry install</code>:</p> <pre><code>poetry install --with dev\npoetry run tox\n</code></pre> <p>Poetry will create its own virtualenv isolated from your system and install the dependencies in it. We installed extra dependency need by developer with the <code>--with dev</code> option, such as documentation build tools, lint, formatting and test tools etc.</p> <p>We also launch a test here by running <code>poetry run tox</code>. This will run <code>tox</code> within created virtual environment, give you a test report and lint report. You should see no errors except some lint warnings.</p> <p>You can also activate the virtual environment manually with <code>poetry shell</code>, this will create a new shell.</p> Tips <p>Extra dependencies are grouped into three groups, doc, dev and test for better granularity. When you ship the package, dependencies in group doc, dev and test might not be shipped.</p> <p>As the developer, you will need install all the dependencies.</p> Tips <p>if you found erros like the following during tox run: <pre><code>ERROR: InterpreterNotFound: python3.9\n</code></pre> don't be panic, this is just because python3.x is not found on your machine. If you decide to support that version of Python in your package, please install it on your machine. Otherwise, remove it from tox.ini and pyproject.toml (search python3.x then remove it).</p>"},{"location":"tutorial/#step-5-create-a-github-repo","title":"Step 5: Create a GitHub Repo","text":"<p>Create a new GitHub repo. Do not initialize with a README or any other files.</p> <p>Follow the instructions there for uploading your existing repo from the command line. It should look something like this (where { owner name } is your GitHub username and { repo name } is the name of your repo):</p> <pre><code>git init\ngit add .\ngit commit -m \"initial commit\"\ngit branch -M main\ngit remote add origin https://github.com/{ owner name }/{ repo name }.git\ngit push -u origin main\n</code></pre>"},{"location":"tutorial/#add-permissions","title":"Add permissions","text":"<p>settings -&gt; actions -&gt; workflow permissions -&gt; read and write permissions</p>"},{"location":"tutorial/#step-7-upload-code-to-github","title":"Step 7: Upload code to GitHub","text":"<p>Back to your develop environment, find the folder named after the <code>project_slug</code>. Move into this folder, and then setup git to use your GitHub repo and upload the code:</p> <pre><code>cd my-package\n\ngit add .\ngit commit -m \"Initial commit.\"\ngit branch -M main\ngit remote add origin git@github.com:myusername/my-package.git\ngit push -u origin main\n</code></pre> <p>Where <code>myusername</code> and <code>my-package</code> are adjusted for your username and repo name.</p> <p>You'll need a ssh key to push the repo. You can Generate a key or Add an existing one.</p> Warning <p>if you answered 'yes' to the question if install pre-commit hooks at last step, then you should find pre-commit be invoked when you run <code>git commit</code>, and some files  may be modified by hooks. If so, please add these files and commit again.</p>"},{"location":"tutorial/#check-result","title":"Check result","text":"<p>After pushing your code to GitHub, goto GitHub web page, navigate to your repo, then click on actions link, you should find screen like this:</p> <p></p> <p>There should be some workflows running. After they finished, go to TestPyPI, check if a new artifact is published under the name <code>project_slug</code>.</p>"},{"location":"tutorial/#step-8-check-documentation","title":"Step 8. Check documentation","text":"<p>Documentation will be published and available at https://{your_github_account}.github.io/{your_repo} once:</p> <ol> <li>the commit is tagged, and the tag name is started with 'v' (lower case)</li> <li>build/testing executed by GitHub CI passed</li> </ol> <p>If you'd like to see what it's look like now, you could run the following command:</p> <pre><code>poetry run mkdocs serve\n</code></pre> <p>This will run the builtin development server for you to preview.</p>"},{"location":"tutorial/#step-9-make-official-release","title":"Step 9. Make official release","text":"<p>After done with your phased development in a feature branch, make a pull request, following instructions at release checklist, trigger first official release and check result at PyPI.</p>"}]}